#!/usr/bin/env node

/**
 * Generate Table Map Script
 * 
 * Reads schema/schema.sql and generates TypeScript types and constants
 * for all tables and their allowed columns.
 */

import * as fs from 'fs';
import * as path from 'path';

interface TableInfo {
  name: string;
  columns: string[];
}

function parseSchema(schemaContent: string): TableInfo[] {
  const tables: TableInfo[] = [];
  
  // Regex to match CREATE TABLE blocks
  const tableRegex = /CREATE\s+TABLE\s+public\.(\w+)\s*\(([\s\S]*?)\);/gi;
  let match;
  
  while ((match = tableRegex.exec(schemaContent)) !== null) {
    const tableName = match[1];
    const tableBody = match[2];
    
    // Parse columns from table body
    const columns = parseColumns(tableBody);
    
    tables.push({
      name: tableName,
      columns: columns.sort() // Sort alphabetically
    });
  }
  
  return tables.sort((a, b) => a.name.localeCompare(b.name));
}

function parseColumns(tableBody: string): string[] {
  const columns: string[] = [];
  const lines = tableBody.split('\n');
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    // Skip empty lines, comments, and constraint lines
    if (!trimmed || 
        trimmed.startsWith('--') || 
        trimmed.startsWith('CONSTRAINT') ||
        trimmed.startsWith('PRIMARY KEY') ||
        trimmed.startsWith('FOREIGN KEY') ||
        trimmed.startsWith('UNIQUE') ||
        trimmed.startsWith('CHECK')) {
      continue;
    }
    
    // Extract column name (first word that's not quoted)
    const words = trimmed.split(/\s+/);
    if (words.length > 0) {
      const columnName = words[0].replace(/,$/, ''); // Remove trailing comma
      
      // Skip if it looks like a constraint or other SQL keyword
      if (!columnName.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {
        continue;
      }
      
      columns.push(columnName);
    }
  }
  
  return columns;
}

function generateTypeScript(tables: TableInfo[]): string {
  const tableNames = tables.map(t => `'${t.name}'`).join(' | ');
  
  let output = `// =========================================================
// AUTO-GENERATED TABLE MAP
// =========================================================
// Generated by scripts/generateTableMap.ts
// Do not edit this file manually - run 'pnpm gen:tables' instead

export type TableName = ${tableNames};

export const TABLE_COLUMNS: Record<TableName, readonly string[]> = {
`;

  // Generate TABLE_COLUMNS
  for (const table of tables) {
    const columns = table.columns.map(col => `'${col}'`).join(', ');
    output += `  '${table.name}': [${columns}] as const,\n`;
  }
  
  output += `} as const;

export const ALLOWED_COLUMNS: Record<TableName, readonly string[]> = {
`;

  // Generate ALLOWED_COLUMNS (exclude 'id' and 'search_vector')
  for (const table of tables) {
    const allowedColumns = table.columns
      .filter(col => col !== 'id' && col !== 'search_vector')
      .map(col => `'${col}'`)
      .join(', ');
    output += `  '${table.name}': [${allowedColumns}] as const,\n`;
  }
  
  output += `} as const;

// Helper type for getting allowed columns for a specific table
export type AllowedColumnsForTable<T extends TableName> = typeof ALLOWED_COLUMNS[T][number];

// Type for update patches
export type UpdatePatch<T extends TableName> = Partial<Record<AllowedColumnsForTable<T>, unknown>>;
`;

  return output;
}

async function main() {
  console.log('üîß Generating table map from schema...');
  
  try {
    // Read schema file
    const schemaPath = path.join(process.cwd(), 'schema', 'schema.sql');
    
    if (!fs.existsSync(schemaPath)) {
      throw new Error(`Schema file not found at: ${schemaPath}`);
    }
    
    const schemaContent = fs.readFileSync(schemaPath, 'utf8');
    
    // Parse tables
    const tables = parseSchema(schemaContent);
    
    if (tables.length === 0) {
      throw new Error('No tables found in schema file');
    }
    
    // Generate TypeScript output
    const tsContent = generateTypeScript(tables);
    
    // Ensure lib directory exists
    const libDir = path.join(process.cwd(), 'lib');
    if (!fs.existsSync(libDir)) {
      fs.mkdirSync(libDir, { recursive: true });
    }
    
    // Write output file
    const outputPath = path.join(libDir, 'adminTables.ts');
    fs.writeFileSync(outputPath, tsContent, 'utf8');
    
    // Log summary
    console.log(`‚úÖ Generated table map successfully!`);
    console.log(`üìä Summary:`);
    console.log(`   - Tables found: ${tables.length}`);
    console.log(`   - Output file: ${outputPath}`);
    console.log(`\nüìã Tables and column counts:`);
    
    for (const table of tables) {
      const allowedCount = table.columns.filter(col => col !== 'id' && col !== 'search_vector').length;
      console.log(`   - ${table.name}: ${table.columns.length} total, ${allowedCount} allowed`);
    }
    
    console.log(`\nüéâ Run 'pnpm gen:tables' anytime the schema changes to refresh this file.`);
    
  } catch (error) {
    console.error('‚ùå Failed to generate table map:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

export { main as generateTableMap };


